<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Client-Side Chess Coach (Stockfish + WebLLM)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; display: grid; grid-template-columns: 480px 1fr; gap: 16px; padding: 16px; }
    header { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; }
    .row { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
    button { padding: 8px 12px; border-radius: 8px; border: 1px solid #d1d5db; background: #f9fafb; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: default; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #pv, #llmOut, #log { white-space: pre-wrap; }
    .tag { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #eef2ff; border: 1px solid #c7d2fe; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  </style>
  <!-- Board web component -->
  <script type="module" src="https://unpkg.com/chessboard-element@3.4.0/dist/chessboard-element.js"></script>
  <!-- chess.js (ESM) -->
  <script type="module" src="https://esm.run/chess@1.3.0"></script>
</head>
<body>
  <header>
    <h1>Client-Side Chess Coach</h1>
    <div class="row">
      <span class="tag" id="engineStatus">Engine: ⏳</span>
      <span class="tag" id="llmStatus">LLM: ⏳</span>
    </div>
  </header>

  <div class="card">
    <chess-board id="board" style="width: 460px" draggable-pieces></chess-board>
    <div class="row" style="margin-top:8px">
      <button id="newGame">New Game</button>
      <button id="flip">Flip</button>
      <button id="takeback">Takeback</button>
      <button id="bestMove">Ask Engine Move</button>
      <button id="makeExercise" title="Create an exercise from last blunder">Make Exercise</button>
    </div>
  </div>

  <div class="grid2">
    <div class="card">
      <h3>Opening & Tactics Library</h3>
      <div id="openingName"><em>—</em></div>
      <div id="themes" class="row" style="margin-top:6px"></div>
      <hr />
      <strong>Principal Variation</strong>
      <div id="pv" class="mono">—</div>
      <div class="row" style="margin-top:8px">
        <span>Eval:</span><span id="eval">—</span>
      </div>
    </div>

    <div class="card">
      <h3>Coach Commentary (WebLLM)</h3>
      <div id="llmOut">—</div>
    </div>

    <div class="card" style="grid-column: 1 / -1">
      <h3>Exercises</h3>
      <div id="exerciseArea">No exercises yet.</div>
    </div>

    <div class="card" style="grid-column: 1 / -1">
      <h3>Log</h3>
      <div id="log" class="mono" style="max-height: 160px; overflow:auto"></div>
    </div>
  </div>

  <script type="module">
    // ---- Config ----
    const STOCKFISH_PATH = "./stockfish.js"; // or "./stockfish.wasm.js" depending on your build
    const LLM_MODEL = "Phi-3-mini-4k-instruct-q4f16_1"; // small, fast local model

    // ---- Imports already loaded via <script type="module"> tags ----
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";

    // chess.js attaches to global as window.chess by that ESM loader; acquire handle:
    const Chess = window.chess.Chess;

    // ---- State ----
    const game = new Chess();
    const boardEl = document.getElementById("board");
    const logEl = document.getElementById("log");
    const pvEl = document.getElementById("pv");
    const evalEl = document.getElementById("eval");
    const openEl = document.getElementById("openingName");
    const themesEl = document.getElementById("themes");
    const engineStatusEl = document.getElementById("engineStatus");
    const llmStatusEl = document.getElementById("llmStatus");
    const llmOutEl = document.getElementById("llmOut");
    const exerciseArea = document.getElementById("exerciseArea");

    let engineWorker = null;
    let engineReady = false;
    let llmEngine = null;
    let lastAnalysis = null;
    let lastBlunder = null; // {fen, best, mistake, delta, pv}

    // ---- Tiny opening & motif library (seed) ----
    const OPENING_BOOK = [
      { name: "Italian Game", fens: [
        "rnbqkbnr/pppppppp/8/8/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 1",
        "rnbqkbnr/pppp1ppp/8/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 2"
      ]},
      { name: "Sicilian Defence", fens: [
        "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2",
      ]},
      { name: "French Defence", fens: [
        "rnbqkbnr/pppp1ppp/8/4p3/3PP3/8/PPP2PPP/RNBQKBNR b KQkq d3 0 2",
      ]},
    ];

    const TACTIC_THEMES = [
      "fork", "pin", "skewer", "discovered attack", "remove defender",
      "clearance", "deflection", "overloading", "attraction", "zwischenzug"
    ];

    function detectOpeningByFEN(fen) {
      for (const o of OPENING_BOOK) {
        if (o.fens.includes(fen.split(" ").slice(0,4).join(" "))) return o.name;
      }
      return "—";
    }

    // ---- UI helpers ----
    function appendLog(msg) { logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }
    function setBoard() { boardEl.setAttribute("position", game.fen()); }

    // ---- Engine (Stockfish) UCI bridge ----
    function initEngine() {
      engineWorker = new Worker(STOCKFISH_PATH);
      engineWorker.onmessage = (e) => {
        const line = (typeof e.data === "string") ? e.data : (e.data?.data || "");
        if (!line) return;
        if (line.startsWith("uciok")) { engineReady = true; engineStatusEl.textContent = "Engine: ✅"; }
        if (line.startsWith("info")) {
          // parse score and pv
          const scoreMatch = line.match(/\bscore (cp|mate) (-?\d+)/);
          const pvMatch = line.match(/\bpv (.+)$/);
          if (scoreMatch) {
            let evalStr = "";
            if (scoreMatch[1] === "cp") {
              const cp = parseInt(scoreMatch[2], 10);
              evalStr = (cp / 100).toFixed(2);
            } else {
              const m = parseInt(scoreMatch[2], 10);
              evalStr = (m > 0 ? `#${m}` : `#-${-m}`);
            }
            evalEl.textContent = evalStr;
          }
          if (pvMatch) pvEl.textContent = pvMatch[1];
        }
        if (line.startsWith("bestmove")) {
          const m = line.split(" ")[1];
          lastAnalysis = { best: m, pv: pvEl.textContent, eval: evalEl.textContent };
        }
      };
      // Kick UCI
      engineWorker.postMessage("uci");
    }

    function analyzeCurrentPosition(ms = 500, multiPV = 1) {
      if (!engineReady) return;
      const fen = game.fen();
      engineWorker.postMessage("ucinewgame");
      engineWorker.postMessage(`position fen ${fen}`);
      engineWorker.postMessage(`setoption name MultiPV value ${multiPV}`);
      engineWorker.postMessage(`go movetime ${ms}`);
    }

    // ---- LLM (WebLLM) ----
    async function initLLM() {
      try {
        llmEngine = await webllm.CreateMLCEngine(LLM_MODEL, {
          progressCallback: (p) => { llmStatusEl.textContent = `LLM: ${Math.round(p.progress*100)}%`; }
        });
        llmStatusEl.textContent = "LLM: ✅";
      } catch (e) {
        llmStatusEl.textContent = "LLM: ⚠️ failed";
        appendLog("LLM init error: " + e.message);
      }
    }

    async function coachComment(moveSAN, beforeFEN, afterFEN, evalBefore, evalAfter, bestMoveUCI, pv) {
      if (!llmEngine) return;
      const delta = evalAfter - evalBefore;
      const side = game.turn() === "w" ? "Black" : "White"; // after move, it's opponent to move
      const prompt = [
        "You are a chess coach. Explain the last move in 2-3 sentences.",
        `Before FEN: ${beforeFEN}`,
        `After FEN: ${afterFEN}`,
        `Move played (SAN): ${moveSAN}`,
        `Engine eval before: ${evalBefore}, after: ${evalAfter}, delta: ${(delta).toFixed(2)}`,
        `Engine best move (UCI): ${bestMoveUCI || "unknown"}`,
        `Engine PV: ${pv || "-"}`,
        "Focus on ideas (plans, tactics, weaknesses). Short, clear, no fluff."
      ].join("\n");

      const out = await llmEngine.chat.completions.create({
        messages: [
          { role: "system", content: "You are a concise, insightful chess coach." },
          { role: "user", content: prompt }
        ],
        temperature: 0.6,
        max_tokens: 160
      });
      const text = out.choices?.[0]?.message?.content?.trim() || "(no output)";
      llmOutEl.textContent = text;
    }

    // ---- Exercise generation from blunders ----
    function maybeMarkBlunder(beforeEval, afterEval, playedSAN) {
      const drop = (afterEval - beforeEval);
      // If eval after move is worse by ≤ -1.5, mark as blunder
      if (drop <= -1.5) {
        lastBlunder = {
          fen: game.fen(), // current FEN is after the bad move
          playedSAN,
          delta: drop,
          best: lastAnalysis?.best || null,
          pv: lastAnalysis?.pv || null
        };
        appendLog(`Blunder detected: Δ=${drop.toFixed(2)}, played ${playedSAN}, best ${lastBlunder.best || "?"}`);
      }
    }

    function renderExercise(ex) {
      exerciseArea.innerHTML = `
        <div class="row" style="margin-bottom:8px">
          <span class="tag">${ex.type.toUpperCase()}</span>
          <span>Side to move: <strong>${ex.side}</strong></span>
          <span>Eval swing: ${ex.delta.toFixed(2)}</span>
        </div>
        <chess-board id="exBoard" style="width: 360px" position="${ex.fen}"></chess-board>
        <div class="row" style="margin-top:8px">
          <button id="showSolution">Show Engine Line</button>
        </div>
        <div id="solution" class="mono" style="margin-top:6px; white-space: pre-wrap;"></div>
      `;
      document.getElementById("showSolution").onclick = () => {
        document.getElementById("solution").textContent =
          `Best move (UCI): ${ex.best || "?"}\nPV: ${ex.pv || "-"}`;
      };
    }

    // ---- Hook up board moves ----
    boardEl.addEventListener("drag-start", (e) => {
      const { source, piece } = e.detail;
      const turn = game.turn() === "w" ? "w" : "b";
      if ((turn === "w" && piece.search(/^b/) !== -1) ||
          (turn === "b" && piece.search(/^w/) !== -1)) {
        e.preventDefault();
        return;
      }
    });

    boardEl.addEventListener("drop", async (e) => {
      const { source, target } = e.detail;
      const move = game.move({ from: source, to: target, promotion: "q" });
      if (move == null) { e.preventDefault(); return; }

      const beforeFEN = e.detail.position; // pre-move fen from component
      const opening = detectOpeningByFEN(beforeFEN);
      openEl.textContent = opening;
      themesEl.innerHTML = "";
      TACTIC_THEMES.slice(0, 6).forEach(t => {
        const span = document.createElement("span"); span.className="tag"; span.textContent=t; themesEl.appendChild(span);
      });

      setBoard();
      // Analyze before+after quickly
      // 1) Back up one ply to get before eval
      game.undo();
      boardEl.setAttribute("position", game.fen());
      analyzeCurrentPosition(400);
      await new Promise(r => setTimeout(r, 450));
      const evalBefore = parseFloat(evalEl.textContent) || 0;
      // 2) Redo move and analyze after
      game.move(move);
      setBoard();
      analyzeCurrentPosition(600);
      await new Promise(r => setTimeout(r, 650));
      const evalAfter = parseFloat(evalEl.textContent) || 0;

      maybeMarkBlunder(evalBefore, evalAfter, move.san);
      await coachComment(move.san, beforeFEN, game.fen(), evalBefore, evalAfter, lastAnalysis?.best, lastAnalysis?.pv);
    });

    // ---- Controls ----
    document.getElementById("newGame").onclick = () => { game.reset(); setBoard(); pvEl.textContent = "—"; evalEl.textContent = "—"; llmOutEl.textContent = "—"; openEl.textContent="—"; themesEl.innerHTML=""; lastBlunder=null; };
    document.getElementById("flip").onclick = () => boardEl.flip();
    document.getElementById("takeback").onclick = () => { game.undo(); setBoard(); analyzeCurrentPosition(400); };
    document.getElementById("bestMove").onclick = () => { analyzeCurrentPosition(800); };
    document.getElementById("makeExercise").onclick = () => {
      if (!lastBlunder) { exerciseArea.textContent = "No recent blunder to convert."; return; }
      const sideToMove = game.turn() === "w" ? "Black" : "White"; // after our blunder, it's opponent's turn
      renderExercise({ type: "tactic", side: sideToMove, ...lastBlunder });
    };

    // ---- Boot ----
    (async function boot() {
      setBoard();
      initEngine();
      await initLLM();

      // Once engine says hello, set options for human-like (optional)
      const waitReady = setInterval(() => {
        if (engineReady) {
          clearInterval(waitReady);
          engineWorker.postMessage("setoption name UCI_AnalyseMode value true");
          appendLog("Engine ready.");
        }
      }, 100);
    })();
  </script>
</body>
</html>
